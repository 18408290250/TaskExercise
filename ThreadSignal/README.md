任务：一个线程打印A-Z，一个线程打印a-z,一个线程打印1-26（三个线程交替顺序执行） 

打印结果：Aa1Bb1……Zz1



**思路一：无锁**

三个任务，每个线程一个自己的任务，只需要判断当然任务需不需要执行(标识判断)，不需要线程通信(无锁)，最简单

Version1.java





**思路二：有锁**

一个任务 三个线程并发访问 需一个线程执行完，通知另一个等待的线程(顺序，通过加锁实现)，

 **1、拿到锁后判断是否需要执行业务代码（一把锁加判断标识）** 

synchronized + state       Version2.java



 Lock+state                        Version3.java

对于同一个对象锁而言，同一时刻只可能有一个线程拿到了这个锁 ;虽然可能任意线程都能拿到锁，但是state的条件不满足，就不打印，进行下一轮拿锁



Lock(fair) + state             Version7.java

优化：公平锁，减少线程重试次数



Lock+Condition                Version4.java

newCondition；调用该方法会返回与该锁绑定Condition对象实例。  

三个线程生成三个Condition对象，当一个线程打印一个数字之后就调用下一个线程的Condition对象的signal方法唤醒下一个线程，然后调用自己的Condition的await线程进入等待状态。控制线程执行顺序。



 **2、只有拿到锁才能执行业务代码,拿到锁也应该执行业务代码 （三把锁拿到另两把才执行业务代码）**

 synchronized   Version5.java

同步：一个线程同时拿到两把锁，另外两个线程都只能等待

顺序打印：一个线程只能拿前一个线程执行完被释放的锁和自己的锁；（一个线程打印完之后只能唤醒它的下一个线程，而不是唤醒所有的线程）





总共三把锁

每个线程占用两把锁，分别代表自己(self)和前一个线程（prev）, 三个线程的持有锁情况如下表所示：

| 线程号 | prev锁 | self锁 |
| ------ | ------ | ------ |
| one    | c      | a      |
| two    | a      | b      |
| three  | b      | c      |

每一个线程必须同时持有两个对象锁，才能进行打印操作 

为了控制执行的顺序，必须要先持有prev锁（前一个线程释放的自身对象锁，保证当前线程一定是在前一个线程操作完成后），然后当前线程再申请自己对象锁，两者兼备时打印。



极端情况：

​	同时都拿到prev锁，self锁都拿不到 死锁

​	或者

​	two线现获得a锁,去拿b锁的时候，b锁被c线程占用

​	解决：线程启动休眠（加大线程之间的启动时间）



问题：最后打印完了，但程序并没有结束，死锁

 最后一次执行完打印操作后，线程就一直处于休眠待唤醒状态，导致线程无法正常结束 

 最直接的思路：就是在最后一次打印操作时在不休眠线程的情况下释放对象锁，使用notifyAll



总结：

程序一共定义了a,b,c三个对象锁，分别对应one、two、three三个线程。one线程最先运行，one线程按顺序申请c,a对象锁，打印操作后按顺序释放a,c对象锁，并且通过notify操作唤醒线程two。线程two首先等待获取a锁，再申请b锁，后打印，再释放b，a锁，唤醒three线程。线程three等待b锁，再申请c锁，后打印，再释放c,b锁，唤醒one线程。



**初始条件限定**：三个线程必须按照one,two,three的顺序来启动 （线程启动休眠）



**思路三：控制并发的数量**

Semaphore                      Version6.java

 Semaphore信号量，是操作系统中的一个概念，在Java并发编程中，信号量控制的是线程并发的数量 



public Semaphore(int permits)
其中参数permits就是允许同时运行的线程数目; 

一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。

Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore。

Semaphore semaphore = new Semaphore(permits);  
semaphore.acquire();  
//do something here  
semaphore.release(); 

